package app.Function.services;

import app.Function.DAO.MovieDAO;
import app.Instance.DTO.MovieDTO;
import app.Instance.entities.MovieEntity;
import app.exceptions.ApiException;
import jakarta.persistence.EntityManagerFactory;

import java.util.List;
import java.util.stream.Collectors;

/**
 * MovieService - Clean implementation using generic AbstractService
 */
public class MovieService extends AbstractService<MovieDTO, MovieEntity, Integer> {

    private final MovieDAO movieDAO;

    public MovieService(EntityManagerFactory emf) {
        super(emf, new MovieDAO(emf));
        this.movieDAO = (MovieDAO) dao; // Cast for additional methods
    }

    // ===========================================
    // CONVERSION METHODS - Required implementation from AbstractService
    // ===========================================
    @Override
    protected MovieDTO convertToDTO(MovieEntity movieEntity) {
        return new MovieDTO(
            movieEntity.getId(),
            movieEntity.getTitle(),
            movieEntity.getReleaseYear(),
            movieEntity.getOriginalLanguage(),
            movieEntity.getGenreEntities().stream()
                .map(genre -> genre.getId())
                .collect(Collectors.toSet())
        );
    }

    @Override
    protected MovieEntity convertToEntity(MovieDTO dto) {
        return MovieEntity.builder()
            .id(dto.getId())
            .title(dto.title())
            .releaseYear(dto.releaseYear())
            .originalLanguage(dto.originalLanguage())
            .build();
        // Note: Genre relationships would be handled separately in a full implementation
    }

    @Override
    protected void validateDTO(MovieDTO dto) {
        super.validateDTO(dto);

        if (dto.title() == null || dto.title().trim().isEmpty()) {
            throw ApiException.badRequest("Movie title cannot be null or empty");
        }

        if (dto.releaseYear() != null && dto.releaseYear() < 1800) {
            throw ApiException.badRequest("Release year seems unrealistic");
        }
    }

    // ===========================================
    // BUSINESS-SPECIFIC METHODS
    // ===========================================

    /**
     * Search movies by title
     */
    public List<MovieDTO> searchByTitle(String title) {
        if (title == null || title.trim().isEmpty()) {
            throw ApiException.badRequest("Movie title cannot be null or empty");
        }

        try {
            return movieDAO.findByTitle(title).stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
        } catch (Exception e) {
            throw ApiException.serverError("Failed to search movies by title: " + e.getMessage());
        }
    }

    /**
     * Find movies by director

    public List<MovieDTO> findByDirectorId(Integer directorId) {
        if (directorId == null) {
            throw ApiException.badRequest("Director ID cannot be null");
        }

        try {
            return movieDAO.findByDirectorId(directorId).stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
        } catch (Exception e) {
            throw ApiException.serverError("Failed to find movies by director: " + e.getMessage());
        }
    }

    /**
     * Get all actors in a movie
     */
    public List<String> getActorsByMovie(Integer movieId) {
        MovieEntity movieEntity = dao.findEntityById(movieId)
            .orElseThrow(() -> ApiException.notFound("Movie not found with ID: " + movieId));

        return movieEntity.getActorEntities().stream()
            .map(actor -> actor.getName())
            .collect(Collectors.toList());
    }

    /**
     * Get all genres for a movie
     */
    public List<String> getGenresByMovie(Integer movieId) {
        MovieEntity movieEntity = dao.findEntityById(movieId)
            .orElseThrow(() -> ApiException.notFound("Movie not found with ID: " + movieId));

        return movieEntity.getGenreEntities().stream()
            .map(genre -> genre.getGenreName())
            .collect(Collectors.toList());
    }
